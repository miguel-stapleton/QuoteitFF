import { 
  ServiceChoice, 
  MakeupForm, 
  HairForm, 
  DefaultPrices, 
  CalculationResult, 
  CalculationLine,
  GrandSummary,
  DayBreakdown,
  PriorityWarning
} from '../types';

interface CalculationInput {
  serviceChoice: ServiceChoice;
  makeupForm?: MakeupForm;
  hairForm?: HairForm;
  prices: DefaultPrices;
  weddingDates: string[];
  existingCalculations?: CalculationResult[];
}

export function calculateQuote(input: CalculationInput): {
  calculations: CalculationResult[];
  grandSummary: GrandSummary;
  priorityWarnings: PriorityWarning[];
} {
  const calculations: CalculationResult[] = [];

  // Calculate makeup if selected
  if (input.serviceChoice.makeup && input.makeupForm) {
    const makeupResult = calculateMakeupService(input.makeupForm, input.prices, input.weddingDates);
    
    // Only preserve payments from existing calculations, not the entire calculation
    const existingMakeup = input.existingCalculations?.find(calc => calc.serviceType === 'makeup');
    if (existingMakeup?.payments && existingMakeup.payments.length > 0) {
      makeupResult.payments = [...existingMakeup.payments]; // Copy payments array
      makeupResult.totalPaid = existingMakeup.payments.reduce((sum, payment) => sum + payment.amount, 0);
      makeupResult.due = Math.max(0, makeupResult.subtotal - makeupResult.totalPaid);
    }
    
    // Generate priority warnings based on current payments and form data
    const numPeople = input.makeupForm?.perDay?.reduce((max, day) => Math.max(max, day.numPeople || 1), 1) || 1;
    makeupResult.priorityWarnings = generatePriorityWarnings(
      'makeup',
      input.makeupForm?.artist || '',
      numPeople,
      makeupResult.payments,
      input.prices.makeup.bridalUnit,
      input.prices.makeup.guestUnit
    );
    
    // Preserve manually added warnings from existing calculations
    if (existingMakeup?.priorityWarnings) {
      const manualWarnings = existingMakeup.priorityWarnings.filter(w => !w.autoGenerated);
      makeupResult.priorityWarnings.push(...manualWarnings);
    }
    
    calculations.push(makeupResult);
  }

  // Calculate hair if selected
  if (input.serviceChoice.hair && input.hairForm) {
    const hairResult = calculateHairService(input.hairForm, input.prices, input.weddingDates);
    
    // Only preserve payments from existing calculations, not the entire calculation
    const existingHair = input.existingCalculations?.find(calc => calc.serviceType === 'hair');
    if (existingHair?.payments && existingHair.payments.length > 0) {
      hairResult.payments = [...existingHair.payments]; // Copy payments array
      hairResult.totalPaid = existingHair.payments.reduce((sum, payment) => sum + payment.amount, 0);
      hairResult.due = Math.max(0, hairResult.subtotal - hairResult.totalPaid);
    }
    
    // Generate priority warnings based on current payments and form data
    const numPeople = input.hairForm?.perDay?.reduce((max, day) => Math.max(max, day.numPeople || 1), 1) || 1;
    hairResult.priorityWarnings = generatePriorityWarnings(
      'hair',
      input.hairForm?.artist || '',
      numPeople,
      hairResult.payments,
      input.prices.hair.bridalUnit,
      input.prices.hair.guestUnit
    );
    
    // Preserve manually added warnings from existing calculations
    if (existingHair?.priorityWarnings) {
      const manualWarnings = existingHair.priorityWarnings.filter(w => !w.autoGenerated);
      hairResult.priorityWarnings.push(...manualWarnings);
    }
    
    calculations.push(hairResult);
  }

  // Calculate grand summary
  const grandSummary = calculateGrandSummary(calculations);

  // Generate priority warnings
  const priorityWarnings: PriorityWarning[] = [];
  calculations.forEach(calc => {
    if (calc.serviceType === 'makeup') {
      const numPeople = Math.max(1, calc.dayBreakdowns.reduce((sum, day) => sum + day.lines.reduce((s, line) => s + (line.label === 'Guests' ? line.qty : 0), 0), 0));
      const warnings = generatePriorityWarnings(
        'makeup',
        calc.artistName || '',
        numPeople,
        calc.payments,
        calc.lines.find(line => line.label === 'Bridal MU')?.unit || 0,
        calc.lines.find(line => line.label === 'Guests')?.unit || 0
      );
      priorityWarnings.push(...warnings);
    } else if (calc.serviceType === 'hair') {
      const numPeople = Math.max(1, calc.dayBreakdowns.reduce((sum, day) => sum + day.lines.reduce((s, line) => s + (line.label === 'Guests' ? line.qty : 0), 0), 0));
      const warnings = generatePriorityWarnings(
        'hair',
        calc.artistName || '',
        numPeople,
        calc.payments,
        calc.lines.find(line => line.label === 'Bridal H')?.unit || 0,
        calc.lines.find(line => line.label === 'Guests')?.unit || 0
      );
      priorityWarnings.push(...warnings);
    }
  });

  return { calculations, grandSummary, priorityWarnings };
}

function calculateMakeupService(
  form: MakeupForm, 
  prices: DefaultPrices, 
  weddingDates: string[]
): CalculationResult {
  const makeupPrices = prices.makeup;

  // Global (service-level) lines
  const globalLines: CalculationLine[] = [];
  if (form.trials > 0) {
    globalLines.push({
      label: 'Trials',
      qty: form.trials,
      unit: makeupPrices.trialUnit,
      total: form.trials * makeupPrices.trialUnit
    });
  }
  if (form.trialTravelEnabled && form.trialTravelFee > 0) {
    globalLines.push({
      label: 'Trial travel fee',
      meta: form.trialVenue,
      total: form.trialTravelFee
    });
  }

  // Per-day breakdowns
  const dayBreakdowns: DayBreakdown[] = weddingDates.map((date, idx) => {
    const day = form.perDay?.[idx] || {
      scheduledReturn: false,
      scheduledReturnBride: false,
      scheduledReturnGuests: 0,
      guests: 0,
      travelFee: 0,
      numPeople: 1,
      numCars: 1,
      exclusivity: false,
      touchupHours: 0,
      beautyVenue: ''
    };

    const lines: CalculationLine[] = [];

    // Guests
    if (day.guests > 0) {
      lines.push({
        label: 'Guests',
        qty: day.guests,
        unit: makeupPrices.guestUnit,
        total: day.guests * makeupPrices.guestUnit
      });
    }

    // Bridal MU (1 per day)
    lines.push({
      label: 'Bridal MU',
      qty: 1,
      unit: makeupPrices.bridalUnit,
      total: makeupPrices.bridalUnit
    });

    // Scheduled return (guarded)
    const scheduledReturnAllowed = day.travelFee === 0 && day.scheduledReturn;
    const brideSR = scheduledReturnAllowed && day.scheduledReturnBride;
    const guestsSR = scheduledReturnAllowed && day.scheduledReturnGuests > 0 && day.scheduledReturnBride; // guests require bride SR
    if (brideSR) {
      lines.push({
        label: 'scheduled return (bride)',
        qty: 1,
        unit: makeupPrices.scheduledReturnBride,
        total: makeupPrices.scheduledReturnBride
      });
    }
    if (guestsSR) {
      lines.push({
        label: 'scheduled return (guests)',
        qty: day.scheduledReturnGuests,
        unit: makeupPrices.scheduledReturnGuestUnit,
        total: day.scheduledReturnGuests * makeupPrices.scheduledReturnGuestUnit
      });
    }

    // Travel fees (car-based model) per day
    if (day.travelFee > 0) {
      const numPeople = Math.max(1, (day as any).numPeople || 1);
      const numCars = Math.max(0, day.numCars || 0);
      const carCount = Math.min(numCars, numPeople);
      const assistantsCount = Math.max(0, numPeople - numCars);

      // 1) Travelling fee (cars)
      const travellingCarsTotal = day.travelFee * carCount;
      if (travellingCarsTotal > 0) {
        lines.push({
          label: 'Travelling fee (cars)',
          qty: carCount,
          unit: day.travelFee,
          total: travellingCarsTotal
        });
      }

      // 2) Assistant travel fee = 35% × travelFee × assistants
      const assistantUnit = 0.35 * day.travelFee;
      const assistantTravelTotal = assistantUnit * assistantsCount;
      if (assistantTravelTotal > 0) {
        lines.push({
          label: 'Assistant travel fee',
          meta: '35% × (people − cars)',
          qty: assistantsCount,
          unit: +assistantUnit.toFixed(2),
          total: +assistantTravelTotal.toFixed(2)
        });
      }
    }

    // Exclusivity (per day toggle)
    if (day.exclusivity) {
      lines.push({ label: 'Exclusivity fee', total: makeupPrices.exclusivityFee });
    }

    // Touch-ups (per day)
    if (day.touchupHours > 0) {
      lines.push({
        label: 'Touch-ups',
        meta: `${day.touchupHours}h`,
        qty: day.touchupHours,
        unit: makeupPrices.touchupHourly,
        total: day.touchupHours * makeupPrices.touchupHourly
      });
    }

    const subtotal = lines.reduce((s, l) => s + l.total, 0);
    return { date, lines, subtotal, venue: day.beautyVenue || undefined };
  });

  // Aggregate totals
  const perDayTotal = dayBreakdowns.reduce((s, d) => s + d.subtotal, 0);
  const globalTotal = globalLines.reduce((s, l) => s + l.total, 0);
  const subtotal = perDayTotal + globalTotal;

  // Flatten lines with date meta for backward-compatible display/exports
  const allLines: CalculationLine[] = [
    ...globalLines,
    ...dayBreakdowns.flatMap((d) => d.lines.map(line => ({
      ...line,
      meta: line.meta ? `${d.date ? new Date(d.date).toLocaleDateString('en-GB') : 'Day'} • ${line.meta}` : (d.date ? new Date(d.date).toLocaleDateString('en-GB') : undefined)
    })))
  ];

  return {
    artistName: form.artist || '',
    serviceType: 'makeup' as const,
    lines: allLines,
    subtotal,
    payments: [],
    totalPaid: 0,
    due: subtotal,
    weddingDates,
    venueNotes: form.trialVenue || '',
    dayBreakdowns,
    priorityWarnings: []
  };
}

function calculateHairService(
  form: HairForm, 
  prices: DefaultPrices, 
  weddingDates: string[]
): CalculationResult {
  const hairPrices = prices.hair;

  // Global (service-level) lines
  const globalLines: CalculationLine[] = [];
  if (form.trials > 0) {
    globalLines.push({
      label: 'Trials',
      qty: form.trials,
      unit: hairPrices.trialUnit,
      total: form.trials * hairPrices.trialUnit
    });
  }
  if (form.trialTravelEnabled && form.trialTravelFee > 0) {
    globalLines.push({
      label: 'Trial travel fee',
      meta: form.trialVenue,
      total: form.trialTravelFee
    });
  }

  // Per-day breakdowns
  const dayBreakdowns: DayBreakdown[] = weddingDates.map((date, idx) => {
    const day = form.perDay?.[idx] || {
      scheduledReturn: false,
      scheduledReturnBride: false,
      scheduledReturnGuests: 0,
      guests: 0,
      travelFee: 0,
      numPeople: 1,
      numCars: 1,
      exclusivity: false,
      touchupHours: 0,
      beautyVenue: ''
    };

    const lines: CalculationLine[] = [];

    // Guests
    if (day.guests > 0) {
      lines.push({
        label: 'Guests',
        qty: day.guests,
        unit: hairPrices.guestUnit,
        total: day.guests * hairPrices.guestUnit
      });
    }

    // Bridal H (1 per day)
    lines.push({
      label: 'Bridal H',
      qty: 1,
      unit: hairPrices.bridalUnit,
      total: hairPrices.bridalUnit
    });

    // Scheduled return (guarded)
    const scheduledReturnAllowed = day.travelFee === 0 && day.scheduledReturn;
    const brideSR = scheduledReturnAllowed && day.scheduledReturnBride;
    const guestsSR = scheduledReturnAllowed && day.scheduledReturnGuests > 0 && day.scheduledReturnBride; // guests require bride SR
    if (brideSR) {
      lines.push({
        label: 'scheduled return (bride)',
        qty: 1,
        unit: hairPrices.scheduledReturnBride,
        total: hairPrices.scheduledReturnBride
      });
    }
    if (guestsSR) {
      lines.push({
        label: 'scheduled return (guests)',
        qty: day.scheduledReturnGuests,
        unit: hairPrices.scheduledReturnGuestUnit,
        total: day.scheduledReturnGuests * hairPrices.scheduledReturnGuestUnit
      });
    }

    // Travel fees (car-based model) per day
    if (day.travelFee > 0) {
      const numPeople = Math.max(1, (day as any).numPeople || 1);
      const numCars = Math.max(0, day.numCars || 0);
      const carCount = Math.min(numCars, numPeople);
      const assistantsCount = Math.max(0, numPeople - numCars);

      // 1) Travelling fee (cars)
      const travellingCarsTotal = day.travelFee * carCount;
      if (travellingCarsTotal > 0) {
        lines.push({
          label: 'Travelling fee (cars)',
          qty: carCount,
          unit: day.travelFee,
          total: travellingCarsTotal
        });
      }

      // 2) Assistant travel fee = 35% × travelFee × assistants
      const assistantUnit = 0.35 * day.travelFee;
      const assistantTravelTotal = assistantUnit * assistantsCount;
      if (assistantTravelTotal > 0) {
        lines.push({
          label: 'Assistant travel fee',
          meta: '35% × (people − cars)',
          qty: assistantsCount,
          unit: +assistantUnit.toFixed(2),
          total: +assistantTravelTotal.toFixed(2)
        });
      }
    }

    // Exclusivity (per day toggle)
    if (day.exclusivity) {
      lines.push({ label: 'Exclusivity fee', total: hairPrices.exclusivityFee });
    }

    // Touch-ups (per day)
    if (day.touchupHours > 0) {
      lines.push({
        label: 'Touch-ups',
        meta: `${day.touchupHours}h`,
        qty: day.touchupHours,
        unit: hairPrices.touchupHourly,
        total: day.touchupHours * hairPrices.touchupHourly
      });
    }

    const subtotal = lines.reduce((s, l) => s + l.total, 0);
    return { date, lines, subtotal, venue: day.beautyVenue || undefined };
  });

  // Aggregate totals
  const perDayTotal = dayBreakdowns.reduce((s, d) => s + d.subtotal, 0);
  const globalTotal = globalLines.reduce((s, l) => s + l.total, 0);
  const subtotal = perDayTotal + globalTotal;

  // Flatten lines with date meta for backward-compatible display/exports
  const allLines: CalculationLine[] = [
    ...globalLines,
    ...dayBreakdowns.flatMap((d) => d.lines.map(line => ({
      ...line,
      meta: line.meta ? `${d.date ? new Date(d.date).toLocaleDateString('en-GB') : 'Day'} • ${line.meta}` : (d.date ? new Date(d.date).toLocaleDateString('en-GB') : undefined)
    })))
  ];

  return {
    artistName: form.artist || '',
    serviceType: 'hair' as const,
    lines: allLines,
    subtotal,
    payments: [],
    totalPaid: 0,
    due: subtotal,
    weddingDates,
    venueNotes: form.trialVenue || '',
    dayBreakdowns,
    priorityWarnings: []
  };
}

function calculateGrandSummary(calculations: CalculationResult[]): GrandSummary {
  const grandTotal = calculations.reduce((sum, calc) => sum + calc.subtotal, 0);
  const totalPaid = calculations.reduce((sum, calc) => sum + calc.totalPaid, 0);
  const totalDue = grandTotal - totalPaid;
  
  return {
    grandTotal,
    totalPaid,
    totalDue: Math.max(0, totalDue)
  };
}

function generatePriorityWarnings(
  serviceType: 'makeup' | 'hair',
  artistName: string = '',
  numPeople: number,
  payments: { occasion: string }[],
  bridalUnitPrice: number,
  guestUnitPrice: number
): PriorityWarning[] {
  const warnings: PriorityWarning[] = [];
  const isMakeup = serviceType === 'makeup';
  const serviceLabel = isMakeup ? 'MUA' : 'HS';
  const serviceName = isMakeup ? 'make-up artist' : 'hairstylist';
  
  // Check for Main Artist Deposit using fuzzy matching
  const hasMainDeposit = payments.some(p => {
    const occasion = p.occasion.toLowerCase();
    return occasion.includes('main') && 
           (occasion.includes('mua') || occasion.includes('makeup') || occasion.includes('make-up') || 
            occasion.includes('hs') || occasion.includes('hair')) && 
           occasion.includes('deposit');
  });
  
  if (!hasMainDeposit) {
    const depositAmount = (bridalUnitPrice / 2).toFixed(2);
    warnings.push({
      id: `auto_main_${serviceType}_${Date.now()}`,
      text: `Main ${serviceLabel} Deposit(s): your date with ${artistName} is not secure until a deposit of €${depositAmount} has been received.`,
      autoGenerated: true
    });
  }
  
  // Check for Assistant Deposits if numPeople > 1
  if (numPeople > 1) {
    const hasAssistantDeposit = payments.some(p => {
      const occasion = p.occasion.toLowerCase();
      return occasion.includes('assistant') && 
             (occasion.includes('mua') || occasion.includes('makeup') || occasion.includes('make-up') || 
              occasion.includes('hs') || occasion.includes('hair')) && 
             occasion.includes('deposit');
    });
    
    if (!hasAssistantDeposit) {
      const numAssistants = numPeople - 1;
      warnings.push({
        id: `auto_assistant_${serviceType}_${Date.now()}`,
        text: `Assistant ${serviceLabel} Deposit(s): there ${numAssistants === 1 ? 'is' : 'are'} ${numAssistants} assistant ${serviceName}${numAssistants === 1 ? '' : 's'} described in your quote, but this artist will only be booked once a €${guestUnitPrice.toFixed(2)} deposit has been received.`,
        autoGenerated: true
      });
    }
  }
  
  return warnings;
}
